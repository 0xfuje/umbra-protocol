{
  "Home": {
    "header": "发送隐形付款",
    "description": "只有汇款人和收款人知道谁收到了资金",
    "Tutorial": {
      "tutorial": "教程",
      "receiving-funds": "接收资金",
      "receive-first": "使用<span class=\"text-bold\">注册</span>页配置您的帐户",
      "receive-second": "要求某人通过 Umbra 应用程序向您的地址、ENS 或 CNS 名称发送资金",
      "receive-third": "查看<span class=\"text-bold\">接收</span>页面以提取资金",
      "sending-funds": "发送资金",
      "send-first": "获取您要向其汇款的人员的地址、ENS 或 CNS 姓名",
      "send-second": "填写<span class=\"text-bold\">发送</span>页面上的表单"
    }
  },
  "Home-action-card": {
    "send": "发送",
    "send-description": "向其他用户发送资金",
    "receive": "接收",
    "receive-description": "查看和提取收到的资金",
    "setup": "注册",
    "setup-description": "注册您的帐户以接收资金"
  },
  "Header-Links": {
    "home": "主页",
    "FAQ": "常见问题",
    "contact": "联系"
  },
  "Base-Layout": {
    "settings": "设置",
    "dark-mode": "深色模式",
    "advanced-mode": "高级模式",
    "advanced-mode-description": "启用高级功能，如私钥导出、其他收件人 ID 选项和事件扫描设置。",
    "caution": "请谨慎使用！",
    "on": "开",
    "off": "关",
    "about": "简介",
    "built-by": "<a href=\"https://www.scopelift.co/\" target=\"_blank\" class=\"hyperlink\">ScopeLift</a> 项目",
    "terms": "Terms of Service",
    "privacy": "Privacy Policy",
    "links": "更多"
  },
  "FAQ": {
    "faq": "常见问题",
    "intro": "介绍",
    "what-is-umbra": "什么是 Umbra?",
    "what-is-umbra-answer": "<p>Umbra 是以太坊的隐身地址协议。 这意味着它允许付款人将资金发送到新地址。 该地址由预期的接收者控制，但只有付款人和接收者知道这一点。 </p><p> 思考 Umbra 的一种方式是：想象一下，如果在有人向您发送资金之前，您向他们发送了一个全新的、从未使用过的地址。 只有发件人会知道您控制该地址，这为您的付款增加了一层隐私。 通过 Umbra 付款的工作方式类似，但不是交互式的——你不需要给别人一个新的地址，他们可以生成一个他们知道只有你才能访问的地址。</p>",
    "an-example": "你能给我举个例子吗？",
    "an-exmaple-answer": "<p>Alice 拥有一家企业，并聘请 Bob 为她分包。她同意为 Bob 的工作支付 1,000 Dai/周。 Bob 拥有 ENS 地址 <span class=\"code\">bob.eth</span>。 如果 Alice 每周将资金发送到 <span class=\"code\">bob.eth</span>，那么任何查看该链的人都可以容易知道 Alice 每周向 Bob 支付 1,000 Dai。</p><p>相反，Bob 和 Alice 将使用 Umbra 进行私人支付。 Bob 第一次访问 Umbra 应用程序时，他设置了自己的帐户，使任何人都可以使用他的地址私下向他付款。然后 Alice 每周使用 Umbra 向 Bob 发送 1,000 Dai ——她只需要知道他的地址或 ENS 名称。</p><p>在链上，我们可以看到 Alice 每周向一个新的空地址支付 1,000 Dai。在幕后，Bob 通过 Umbra 控制每个地址的密钥，但除了 Alice 和 Bob 之外没有人知道这一点。</p><p>Bob 每周使用 Umbra 提取他的 1,000 Dai。他只需要提供一个地址即可将其发送到。他最好使用与他的身份无关的地址。他通常选择直接将其发送到交易所，并根据需要将其出售为法定货币。重要的是，这意味着<strong>Bob 的交易所现在知道这笔款项是给他的</strong>。 对于不经意的链观察者——一个无法访问专有中心化交易所数据的人——Alice 的付款流向 Bob 的事实是掩盖的。</p><p> 再举一个例子：Liza 经营着一个请求捐款的网站。如果大家直接给她捐款，大家都会知道丽莎收到了多少捐款。如果改为使用 Umbra 发送捐款，则每笔捐款将被发送到不同的地址，只有 Liza 才能知道她收到的捐款总额。</p>",
    "wen-token": "Umbra 有代币吗？",
    "wen-token-answer": "没有。",
    "how-does-it-work": "它是如何工作的？",
    "how-does-it-work-answer": "<p>下面是对 Umbra 工作原理的简介：</p><ol><li>在设置您的 Umbra 帐户时，用户会签署一条消息。此消息的散列用于生成两个私钥——一个“支出密钥”和一个“查看密钥”。 </li> <li>相应的公钥都作为与您的地址关联的记录在链上发布。</li><li>付款人使用您的地址或 ENS 名称来查找您的两个公钥。另外，付款人生成一个随机数。</li><li>随机数与支出公钥一起使用，以生成一个“隐形地址”来发送资金。与查看公钥使用相同的随机数来加密随机数。</li><li> 使用 Umbra 合约，付款人将资金发送到隐身地址，加密数据作为 <span class=\"code\">Announcement</span>  事件发出。</li><li>接收方扫描 Umbra 合约中的所有 <span class=\"code\">Announcement</span> 事件。对于每个人，他们使用他们的查看密钥来解密随机数，然后将该数字乘以他们的支出密钥来生成隐形私钥。如果隐形私钥控制资金发送到的地址，则这笔款项是给收款人的。</li> <li> 接收方现在可以使用私钥直接将提取资金所需的交易发送到另一个地址，或者签署元交易以让中继器处理取款请求。</li></ol><p>请参阅”<span class=\"hyperlink\" @click=\"expandAndScrollToElement('how-does-it-work-technical')\">“技术细节：它是如何工作的？“</span> 部分了解更多详情。</p>",
    "how-private": "Umbra 有多私密？",
    "how-private-answer": "<p>Umbra 提供了一组有限的隐私保证，在使用协议之前了解它们很重要。 Umbra <span class=\"text-bold\">不像</span> Aztec 或 Zcash 那样提供“完整”隐私。 它只是让任何外部观察者（即任何不是发送者或接收者的人）都无法通过查看接收地址来知道发送者为谁付款。</p><p>重要的是要了解接收方的安全状况不佳（例如，将资金直接发送到公开地址）会消除发送方和接收方的隐私利益。</p><p>如果观察者可以缩小给定交易的潜在接收者的范围，Umbra 的隐私属性也可以被减少。任何有效的公钥都可以用作接收者，任何在以太坊上发送过交易的人都有一个公开的公钥。因此，默认情况下，“匿名集”——交易的潜在接收者的集合——是任何曾经发送过以太坊交易的人！</p><p>在实践中，情况不一定如此，观察者可以通过以下几种方式缩小收件人列表范围：</p><ol><li>大多数用户将使用 Umbra 隐形密钥注册表来发送资金，因此接收者很可能在其中发布了密钥。</li><li>从您的隐身地址提取资金时不小心会减少或使 Umbra 提供的隐私属性无效。请参阅“取款到哪个地址是安全的？”更多细节。取款时请务必小心！</li></ol>",
    "umbra-vs-tornado" : "Umbra 与 TornadoCash 和 Aztec 相比如何？",
    "umbra-vs-tornado-answer": "<p> Tornado Cash 是一个使用零知识证明的链上混合器。您存入资金并收到一个秘密票据，等待一段时间让其他人也这样做，然后使用您的票据证明您拥有一些存入资金并将其提取到另一个地址。由于每个人的资金都集中在混音器中，因此存款地址和提款地址之间的链接可以被断开。</p> <p> Aztec 是一个以隐私为中心的第 2 层解决方案，它也使用零知识证明。您将来自第 1 层（主网）的资金存入 Aztec，您的资金有效地被“包裹”在一个私人版本中。默认情况下，定期转账是私密的，这意味着没有人知道您向谁汇款，或者你支付了多少钱。余额通常是私人的，因此没有人可以看到您持有多少资金。</p> <p> Umbra 与这两者不同，并且不使用零知识证明。相反，Umbra 基于普通的椭圆曲线密码学。它适用于两个人或商户之间的支付，并带有一组不同的隐私权衡。 Umbra 并没有像 Tornado 那样断开发送和接收地址之间的链接，而是使该链接变得毫无意义。每个人都可以看到谁发送了资金，每个人都可以看到资金发送到的地址，但是这个接收地址从来没有在链上被用过，所以任何外部观察者都不可能知道谁在控制它。</p>",
    "account-setup": "帐户注册",
    "what-is-setup": "什么是账户注册？",
    "what-is-setup-answer": " <p> 用户签署一条消息，并从中生成 Umbra 公钥和私钥。 在 Umbra 隐形密钥注册表上进行交易，将公钥与您的地址相关联。</p>",
    "is-setup-required": "我是否需要注册帐户？",
    "is-setup-required-answer": " <p> 此步骤在技术上不是必需的，但出于安全原因强烈建议执行此步骤。 为了获取隐形资金，Umbra 应用程序需要您的私钥。 将您钱包的私钥输入任何网站都是非常危险的，我们不希望您这样做！ 通过完成帐户设置过程，您签署了一条消息以生成一组特定于应用程序的 Umbra 私钥。 这更加安全，因为 Umbra 从来没有您钱包的私钥。 </p>",
    "why-setup-again": "为什么我需要重新注册我的帐户？",
    "why-setup-again-answer": "<p> 如果您在服务仍处于测试阶段（2021 年 10 月之前）时配置了 Umbra 帐户，则需要重新设置。这需要一个签名和一个交易。 </p> <p> 这个额外的设置步骤是由于升级到 Umbra 的隐形密钥注册表系统。旧系统依赖于与用户地址关联的 ENS 解析器上的记录。新系统要简单得多，并使用用户地址和他们的隐秘密钥之间的简单映射。 </p> <p> 新系统是为了响应 Umbra Beta 期间的用户反馈而开发的。旧系统需要多次交易，还要求发送方使用接收方的 ENS 名称，造成困惑。新系统只需要一次交易，发送者可以提供接收者的 ENS 名称或他们的常规以太坊地址。总体而言，新系统的配置和使用都更简单。 </p> <p> 有关此升级的更深入和技术说明，请参阅 Umbra 的 Github 存储库上的 <a href=\"https://github.com/ScopeLift/umbra-protocol/issues/214\" class=\"hyperlink\" target=\"_blank\" >this issue</a > 此问题。 </p>",
    "sending-funds": "汇款",
    "why-only-tokens": "为什么只有某些代币可用？",
    "why-only-tokens-answer": "<p> 当您发送 ETH 时，ETH 会直接发送到计算出的隐身地址。该隐身地址现在有 ETH，需要支付 gas，因此接收方可以通过普通发送轻松转移该 ETH。 </p> <p> 当您发送代币时，代币不会直接发送到计算出的隐身地址。如果是这样，您首先需要将 ETH 放入隐身地址，以便支付提取资金的 gas（或使用一些昂贵的 CREATE2 方案）。相反，代币由合约持有，可以通过以下两种方式之一释放： </p> <ol> <li>隐身地址直接调用 <span class=\"code\">withdrawToken()</span> 方法</li> <li> 任何人调用 <span class=\"code\">withdrawTokenOnBehalf()</span> 并从隐身地址传递一个签名。这使得元交易可以与您选择的中继器一起使用。 </li> </ol> <p> 默认情况下，Umbra 应用程序使用来自 Umbra 团队的中继器。管理中继器并确保正确报销交易费用可能会很棘手，因此一开始只启用了几个代币，并且支持的代币列表将被扩展。</p>",
    "when-receive": "收款人何时会收到他们的资金？",
    "when-receive-answer": "<p> 立即地！接收者在发送交易被挖掘后，立即收到并可以提取资金。 </p>",
    "min-amount": "为什么有最低发送金额？",
    "min-amount-answer": " <p> 当您使用 Umbra 汇款时，收款人地址是一个以前从未使用过的地址。这意味着它没有 ETH 和代币，因此它必须使用发送给它的资金来支付提款费用。发送 ETH 时，这是通过常规转账完成的。发送代币时，这是通过中继器完成的，因此可以使用收到的代币支付费用。因此，有最低发送金额，以确保收款人始终可以轻松提取资金。 </p>",
    "umbra-fee": "为什么有时会有 Umbra 费用？",
    "umbra-fee-answer": "<p> 您通过 Umbra 收到的资金需要扫描所有已发送的交易，然后检查每笔交易以找到属于您的交易。 </p> <p> 在交易费用非常便宜的网络上，Umbra 合约在发送资金交易时以阻止垃圾信息收取少量费用，因为垃圾信息会使扫描所有发送的交易变得更加困难。 </p>",
    "payment-links": "什么是支付链接？",
    "payment-links-answer": " <p> 在发送页面上，填写部分或全部发送表单，然后单击 <span class=\"text-italic\">复制付款链接</span> 按钮。这会将 URL 复制到剪贴板，当访问该剪贴板时，会使用 URL 中的值预先填充发送表单。 </p> <p> 指定金额作为付款链接的一部分时要小心，因为它会降低隐私。例如，如果您分享了一个支付链接，人们可以向您捐赠 100 DAI，突然间大量 100 DAI 开始通过 Umbra，观察者就会知道这些转账很可能是属于您的。 </p>",
    "receiving-funds": "收款",
    "safe-address": "提取资金到哪些地址是安全的？",
    "safe-address-answer": "<p> 我们建议以保护隐私的方式取款3 种方式。请注意，每个都有自己的权衡取舍。 </p> <ol> <li> 提取到与您的身份没有公开关联的地址（权衡：发件人现在可以推断您控制该地址） </li> <li> 生成一个新地址并提取到该地址（权衡：如果您收到了代币，则必须先用 ETH 为该地址注资，然后才能使用它们） </li> <li> 提取到交易所地址（权衡：如果你取款到 Coinbase，那么 Coinbase 会知道谁给您发了资金） </li> </ol>",
    "non-safe-address": "提取资金到哪些地址不安全？",
    "non-safe-address-answer": "<p> 取款时要考虑的风险是，如果您提取到与某些公开身份相关联的地址，那么隐私将丢失如下： </p> <p> 假设 Alice 通过 Umbra 向 Bob 发送资金。现在，只有 Alice 和 Bob 知道 Alice 付钱给 Bob。任何其他观察者都知道 Alice 向某人发送了资金，但他们不知道那个人是谁。 </p> <p> 如果 Bob 将这些资金提取到他公开的bob.eth地址，该地址解析为0x123...def，那么观察者知道发生了以下两件事之一： </p> <ol> <li>场景 1：Alice 向 Bob 发送资金，然后 Bob 将资金提取到他自己的地址，或者</li> <li>场景 2：Alice 向认识 Bob 的人发送资金，并从他们的隐身地址支付 Bob</li> </ol> <p> 此外，考虑 Bob 通过直接向他的朋友 Charlie 支付款项而取款的情况——Charlie 现在知道 Alice 向 Bob 支付了款项。 </p> <p>为了帮助缓解这种情况，如果您输入的提款地址可能会降低您的隐私，Umbra 应用程序会尝试警告您。因此，如果应用检测到您正在提款到以下地址，您会看到警告： </p> <ol> <li>有 ENS 或 CNS 名称</li> <li>拥有 POAP 代币</li> <li>是您登录的钱包</li> <li>（即将推出）：提取到对 Gitcoin 有贡献的地址。</li> </ol> <p> 这些 <span class=\"text-bold\">不是</span> 所有潜在危险提款地址的完整列表，因此请谨慎使用。 </p>",
    "umbra-withdrawal": "Umbra 能否以保护隐私的方式更轻松地提取资金？",
    "umbra-withdrawal-answer": "<p> 是的！这是我们打算在未来进行许多改进的领域，主要是依靠 Umbra 的提款后挂钩功能。 </p> <p>我们计划如何利用这一点的一些示例包括：</p> <ol> <li>直接提取到 Tornado Cash</li> <li>以原子方式将一些代币交换为 ETH，并将其全部发送到新地址</li> <li>将资金直接提取到 DeFi 协议中</li> </ol> <p> 我们可以通过钩子追求许多其他选项，以极大地扩展隐私保护取款选项。 </p>",
    "scan-time": "为什么扫描我的资金需要这么长时间？",
    "scan-time-answer": "<p> 查找给您发送的付款时，该应用程序需要搜索每一笔发送过的付款并检查它是否属于您。因此，已发送的付款越多，所需的时间就越长。 </p> <p> 这是一个具有各种潜在解决方案的研究问题 ( <a class=\"hyperlink\" href=\"https://ethresear.ch/t/open-problem-improving-stealth-addresses/7438\" target=\"_blank\" >1</a >, <a class=\"hyperlink\" href=\"https://eprint.iacr.org/2021/089.pdf\" target=\"_blank\">2</a>)，我们希望随着时间的推移改进这一点。 </p>",
    "when-withdrawal": "我的资金何时可以提取？",
    "when-withdrawal-answer": "<p>立即地！您收到并可以在发送交易被挖掘后立即提取资金。</p>",
    "security": "安全",
    "audit": "Umbra 是否经过审核？",
    "audit-answer": "<p> 这些 <a class=\"hyperlink\" href=\"https://github.com/ScopeLift/umbra-protocol/tree/master/contracts\" target=\"_blank\" >合约</a > 已通过 ConsenSys Diligence 审计，可在 <a class=\"hyperlink\" href=\"https://consensys.net/diligence/audits/2021/03/umbra-smart-contracts/\" target=\"_blank\" >这</a >查阅审计报告。 </p> <p> <span class=\"code\">umbra-js</span>&#32; <a class=\"hyperlink\" href=\"https://github.com/ScopeLift/umbra-protocol/tree/master/umbra-js\" target=\"_blank\" >库</a >&mdash;—负责处理所需的链下逻辑和椭圆曲线操作—已通过Least Authority审计，审计报告可查看 <a class=\"hyperlink\" href=\"https://leastauthority.com/static/publications/LeastAuthority_ScopeLift_Umbra-js_Final_Audit_Report.pdf\" target=\"_blank\" >这里</a >. </p> <p> 链下椭圆曲线操作是 Umbra 业务逻辑的核心部分，所以我们依赖 <a class=\"hyperlink\" href=\"https://paulmillr.com/\" target=\"_blank\">Paul Miller</a>的简单，零依赖的 <a class=\"hyperlink\" href=\"https://github.com/paulmillr/noble-secp256k1\" target=\"_blank\">noble-secp256k1</a> 库来处理。非常感谢 <a class=\"hyperlink\" href=\"https://gitcoin.co/grants/2451/audit-of-noble-secp256k1-cryptographic-library\" target=\"_blank\" >社区</a >帮助，我们能够筹集到足够的资金来支付Cure53 对该库进行审计的费用。您可以在 <a class=\"hyperlink\" href=\"https://cure53.de/pentest-report_noble-lib.pdf\" target=\"_blank\">这里</a>阅读审核报告。 </p>",
    "umbra-risk": "Umbra 的风险是什么？",
    "umbra-risk-answer": "<p> 和其他货币生态系统中的软件一样，使用 Umbra 也存在风险。这包括严重的软件漏洞，黑客攻击、或其他恶意行为者攻击的风险。任何或所有这些情况都可能导致资金损失。 </p> <p>更具体地说，以下是我们过去在其他项目中看到的一些风险：</p> <ol> <li>合同漏洞使攻击者窃取合同资金或使资金冻结</li> <li>我们的链下代码中的一个错误导致资金被发送到一个不可恢复的地址</li> <li>DNS被劫持以窃取用户的私钥</li> <li>前端代码供应链攻击窃取用户私钥</li> </ol> <p> 我们正在努力防止这些风险，但这并不意味着我们会成功。Umbra 不提供任何担保，您应自担风险下使用它。 </p>",
    "crypto-js": "JavaScript 中的密码学是否安全？",
    "crypto-js-answer": " <p> 一般来说，JavaScript 执行环境并不适合满足安全要求。它在将秘密数据隐藏在内存中（例如，您的应用程序特定的私钥）和防止该数据写入磁盘方面提出了挑战。使用 JavaScript 还意味着底层加密库可能容易受到诸如 <a class=\"hyperlink\" href=\"https://en.wikipedia.org/wiki/Timing_attack\" target=\"_blank\">定时攻击</a>。 Umbra 使用 <a class=\"hyperlink\" href=\"https://github.com/paulmillr/noble-secp256k1\" target=\"_blank\">noble-secp256k1</a> 进行所有加密，您可以阅读有关其限制和缓解此类漏洞的更多信息，看 <a class=\"hyperlink\" href=\"https://github.com/paulmillr/noble-secp256k1/#security\" target=\"_blank\">这里</a>。 </p> <p> 然而，以太坊生态系统有许多依赖 JavaScript 密码术的钱包和应用程序，到目前为止还没有因此而出现重大问题，因此这种方法对于大多数用户来说可能是一个合适的折衷方案。 </p>",
    "tech-details": "技术细节",
    "network-addresses": "Umbra 部署在哪些网络上以及合约地址是什么？",
    "network-addresses-answer": " <ul> <li> 核心 <span class=\"code\">Umbra</span> 合约部署在 <span class=\"code\">{{ deployments.umbra }}</span> 上 <a :href=\"getEtherscanUrl(deployments.umbra, 1)\" class=\"hyperlink\" target=\"_blank\"> mainnet </a>, <a :href=\"getEtherscanUrl(deployments.umbra, 4)\" class=\"hyperlink\" target=\"_blank\"> Rinkeby </a>, <a :href=\"getEtherscanUrl(deployments.umbra, 10)\" class=\"hyperlink\" target=\"_blank\"> Optimism </a>, <a :href=\"getEtherscanUrl(deployments.umbra, 137)\" class=\"hyperlink\" target=\"_blank\"> Polygon </a>， 和 <a :href=\"getEtherscanUrl(deployments.umbra, 42161)\" class=\"hyperlink\" target=\"_blank\"> Arbitrum </a> </li> <li> The <span class=\"code\">StealthKeyRegistry</span> 部署在 <span class=\"code\">{{ deployments.registry }}</span> on <a :href=\"getEtherscanUrl(deployments.registry, 1)\" class=\"hyperlink\" target=\"_blank\"> mainnet </a>, <a :href=\"getEtherscanUrl(deployments.registry, 4)\" class=\"hyperlink\" target=\"_blank\"> Rinkeby </a>, <a :href=\"getEtherscanUrl(deployments.registry, 10)\" class=\"hyperlink\" target=\"_blank\"> Optimism </a>, <a :href=\"getEtherscanUrl(deployments.registry, 137)\" class=\"hyperlink\" target=\"_blank\"> Polygon </a>， 和 <a :href=\"getEtherscanUrl(deployments.registry, 42161)\" class=\"hyperlink\" target=\"_blank\"> Arbitrum </a> </li> </ul>",
    "how-it-works": "它是如何工作的？",
    "how-it-works-answer": "<p class=\"text-bold\">隐形地址概述</p> <p>让我们从 Umbra 协议的工作原理（更一般地说，隐身地址的工作原理）开始：</p> <p> 接收者拥有公钥 <span class=\"code\">P</span> 和私钥 <span class=\"code\">p</span>。 发送者生成一个随机数 <span class=\"code\">r</span>，并使用椭圆曲线乘法计算隐身公钥为  <span class=\"code\">P_stealth = P * r</span> 。 发件人从该公钥中派生出以太坊地址 <span class=\"code\">a_stealth</span> ，并向其发送资金。由于椭圆曲线数学的魔力，接收者可以通过计算 <span class=\"code\">p_stealth</span> 生成访问 <span class=\"code\">a_stealth</span> 资金所需的私钥 <span class=\"code\">p_stealth = p * r</span>. </p> <p> 首先要解决的问题是发送方如何将值 <span class=\"code\">r</span> 传递给接收方？如果 <span class=\"code\">r</span> 是公开的，观察者可以通过计算 <span class=\"code\">P * r</span> 来确定向谁发送了各种已发布的 <span class=\"code\">P</span> 值，直到找到隐身地址。所以 <span class=\"code\">r</span> 需要加密。 </p> <p> 加密完成 <a class=\"hyperlink\" href=\"https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\" target=\"_blank\" >Elliptic Curve Diffie-Hellman</a > (ECDH)，这意味着发送者使用接收者的公钥来加密随机数。加密的随机数会给我们密文 <span class=\"code\">c</span>。加密的随机数 <span class=\"code\">c</span> 和隐身地址 <span class=\"code\">a_stealth</span> 作为来自 Umbra 合约的公告 <span class=\"code\">Announcement</span> 事件发出。ECDH 要求发送方生成用于加密的临时私钥，因此接收方需要解密的临时公钥 <span class=\"code\">P_ephemeral</span> 也会在此事件中发出。 </p> <p> 现在接收者可以扫描所有的 <span class=\"code\">Announcement</span> 事件并找到他们的资金，如下所示： </p> <ul> <li> 使用他们的私钥 <span class=\"code\">p</span> 和 <span class=\"code\">P_ephemeral</span>，他们可以计算 ECDH 共享密钥并解密随机数。 这总是会解密为 <span class=\"text-italic\">某些东西</span>，但我们还不知道它是否解密为正确的数字。 </li> <li> 所以接收方将解密后的随机数乘以 <span class=\"code\">p</span> 得到 <span class=\"code\">p_stealth</span>，并计算出 <span class=\"code\">p_stealth</span> 控制的地址</li> <li> 如果 <span class=\"code\">p_stealth</span> 控制的地址与公告中包含的  <span class=\"code\">a_stealth</span>  隐身地址匹配，则收件人知道付款是给他们的，并且可以使用 <span class=\"code\">p_stealth</span>取款。 </li> </ul> <p class=\"text-bold\">应用程序私钥</p> <p> 从上面的解释可以看出，该应用程序需要访问您的私钥才能执行所需的数学运算。但是，当您将钱包连接到应用程序时，钱包不会与应用程序共享您的私钥。这很好，因为如果您使用的任何应用程序都可以窃取您的资金！那么 Umbra 如何访问您的密钥呢？我们有几个选项： </p> <ol> <li> 要求用户将其钱包的私钥输入到表单中。从安全性和用户体验的角度来看，这都很糟糕，所以我们不这样做 </li> <li> 生成一个随机私钥并要求您备份它。这可行，但必须备份特定于应用程序的机密并不理想。 </li> <li>要求用户对消息进行签名，对签名进行哈希处理，并从签名中生成密钥。</li> </ol> <p> 选项 3 解决了选项 1 和 2 的问题，是我们的应用程序使用的方法。类似的方法被使用 <a class=\"hyperlink\" href=\"https://loopring.org/#/\" target=\"_blank\">Loopring</a> 和 <a class=\"hyperlink\" href=\"https://zksync.io/\" target=\"_blank\">zkSync</a> 同样，他们是这种方法的灵感来源。</p> <p class=\"text-bold\">扫描资金</p> <p> 最后的考虑与扫描有关。因为需要扫描每一个 <span class=\"code\">Announcement</span> ，所以可能需要很长时间才能找到您的资金。 </p> <p> 一种加快速度的方法（从用户的角度来看）是将扫描委托给第三方服务，并让他们在您收到资金时通知您。但是扫描服务需要你的私钥 <span class=\"code\">p</span> 来确定你是否收到了资金，如果他们有 <span class=\"code\">p</span> 他们可以窃取你的资金！ </p> <p> 我们可以通过生成两个特定于应用程序的私钥来解决这个问题。一个私钥将是查看私钥 <span class=\"code\">p_view</span>，用于加密随机数。另一个是支出私钥  <span class=\"code\">p_spend</span>，用于计算隐形地址和访问这些资金。因此，我们的发送和接收流程现在稍微修改为： </p> <ol> <li> 接收人有两个私钥 <span class=\"code\">p_spend</span>  和 <span class=\"code\">p_view</span>，并发布对应的公钥 <span class=\"code\">P_spend</span> 和 <span class=\"code\">P_view</span>. </li> <li> 发送者生成一个随机数 <span class=\"code\">r</span> 并使用 <span class=\"code\">P_view</span> 和一个临时私钥  <span class=\"code\">p_ephemeral</span> 对其进行加密以生成密文 <span class=\"code\">c</span> </li> <li> 发件人将隐身地址计算为派生自 <span class=\"code\">P_stealth = P_spend * r</span> 的地址，并将资金发送到该地址 </li> <li> Umbra 合约发出 <span class=\"code\">c</span>, <span class=\"code\">P_ephemeral</span>，和隐身地址 <span class=\"code\">a_stealth</span> </li> <li> 对于每个事件，接收者使用 <span class=\"code\">p_view</span> 和 <span class=\"code\">P_ephemeral</span> 解密 <span class=\"code\">r</span>，然后检查 <span class=\"code\">p_stealth = p_spend * r</span> 是否是控制  a_stealth 的私钥</li> </ol> <p> 通过这种方法，收件人可以通过提供第三方 <span class=\"code\">p_view</span> 和 <span class=\"code\">P_spend</span>来接受扫描服务 。该服务现在可以检查收款人是否已收到资金但第三方没有花钱权利。 </p>",
    "spend-view-keys": "What are spending and viewing keys?",
    "spend-view-keys-answer": "Borrowing the <a class=\"hyperlink\" href=\"https://electriccoin.co/blog/explaining-viewing-keys/\" target=\"_blank\" >nomenclature</a > from Zcash, Umbra allows, but does not require, users to use different private keys for the \"encrypt random number\" and \"compute stealth address\" steps. This is the default behavior of the Umbra app, but it can be overriden by using Advanced Mode. <p> See \"<span class=\"hyperlink\" @click=\"expandAndScrollToElement('how-does-it-work-technical')\" >Technical Details: How does it work?</span >\" for more details on how spending and viewing keys work. </p>",
    "advanced-mode": "Advanced Mode",
    "what-is-advanced": "What is Advanced Mode?",
    "what-is-advanced-answer": "<p> For power users who understand the protocol, how it works, and the risks involved, you may want to enable Advanced Mode. This provides a range of additional capabilities, but improper use can result in privacy being reduced or funds being lost. Use with caution! </p>",
    "send-to-pkey": "How do I send funds to a user by their address or public key?",
    "send-to-pkey-answer": "<p> As long as a user has sent at least one transaction on Ethereum, you can send funds to a stealth address they control even if they have not setup their address for use with Umbra. This works as follows: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Send page and connect your wallet</li> <li>Check the box that says \"Send using recipient's standard public key\"</li> <li> The recipient field normally only accepts addresses in the stealth key registry, and uses the public keys published there to generate stealth address. But now, it will allow you to put in any address, and use the standard public key that underlies that address. It will also accept a public key, an address, or even a transaction hash! (Using a transaction hash is effectively the same as entering the <span class=\"code\">from</span> address of that transaction) </li> <li>Continue to send funds like normal</li> </ol> <p>Be aware of the following tradeoffs incurred when sending funds this way:</p> <ol> <li>This transaction does not use separate spending and viewing keys, and the same key is used for each</li> <li> To withdraw funds from the app, the recipient must enable Advanced Mode and manually paste their private key into the website. This is the big tradeoff, so make sure the recipient is ok with this before sending funds this way. </li> </ol>",
    "access-funds": "How can I access funds sent to me by using my address as the recipient identifier?",
    "access-funds-answer": "<p> If funds were sent to you by using your public key directly, your address, or a transaction hash of a transaction you sent, your funds can still be accessed. </p> <p>The most secure way to do this is locally using the <span class=\"code\">umbra-js</span> package:</p> <ol> <li>Setup a local JavaScript project with <span class=\"code\">yarn init</span></li> <li>Install ethers.js and umbra-js using <span class=\"code\">yarn add ethers @umbra/umbra-js</span></li> <li> In your script, perform the following: <ol> <li>Connect to a mainnet provider with ethers</li> <li> Initialize an instance of the Umbra class with <span class=\"code\">const umbra = new Umbra(provider, 1)</span> </li> <li> Initialize an instance of the KeyPair class with your address’ private key, <span class=\"code\">const keyPair = new KeyPair(myPrivateKey)</span> </li> <li> Use the <span class=\"code\">umbra.scan()</span> method to search for your funds. The <span class=\"code\">viewingPrivateKey</span> input is now be given by <span class=\"code\">keyPair.privateKeyHex</span>, and the <span class=\"code\">spendingPublicKey</span> input is given by <span class=\"code\">keyPair.publicKeyHex</span> </li> <li> For each <span class=\"code\">Announcement</span>, you can use the static method <span class=\"code\" >Umbra.computeStealthPrivateKey(keyPair.privateKeyHex, announcement.randomNumber)</span > to compute the stealth private key </li> </ol> </li> <li> Now that you have the stealth private key(s), you can sign and relay withdrawal transactions using any method you prefer. See the various withdrawal methods in the Umbra class that may be helpful here. </li> </ol> <p> If you prefer convenience over security, you can instead withdraw using the Umbra app, but be careful—entering your private key into a website is never a good idea! If you do want to go this route: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and connect your wallet</li> <li>Before scanning, enter the appropriate private key in the form</li> <li>Leave the start block and end block fields blank if you don’t need them</li> <li>Click \"Scan\" to scan for funds</li> </ol>",
    "scan-range": "How can I scan just certain range of blocks?",
    "scan-range-answer": "<p> If you have an idea of approximately when you were sent funds, you can speed up the scanning process of only querying events within a certain range of blocks. To do this: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and connect your wallet</li> <li>Before scanning, enter the desired start and end block numbers</li> <li>Leave the private key field blank if you don’t need it</li> <li>Click \"Scan\" to scan for funds</li> </ol> <p> The start and end block numbers will be saved in local storage and automatically applied next time you scan with advanced mode on. Leave both fields blank to clear the values and use the defaults. </p>",
    "view-prvkey": "How can I view the stealth private keys?",
    "view-prvkey-answer": "If you want to see the stealth private key for a certain payment you received: <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and scan for funds</li> <li>For transactions that have not been withdrawn, click \"Withdraw\" to expand the row</li> <li> You’ll see text that says \"Show withdrawal private key\", which will show the stealth private key needed to withdraw this payment </li> </ol>",
    "for-developers": "For Developers",
    "build-on-umbra": "How can I build on top of Umbra?",
    "build-on-umbra-answer": "<p> Developer documentation is not yet written, but all code is thoroughly commented so it should be straightforward to read the code to understand how things work and build on top of it. </p> <p> The umbra-js library is a good starting point, as it will give you the full, big picture view of how Umbra works, as well as go into the details. Afterwards, you can check out the contract and to understand exactly where it fits in. </p> <p> The below should be a good order for traversing the umbra-js codebase. If you find this confusing, please let us know what a better order would be! </p> <ol> <li> <span class=\"code\">src/classes/Umbra.ts</span>: The <span class=\"code\">Umbra</span> class is a high-level class intended for developers to directly interact with. It abstracts away the complexity of the protocol into a few main methods: <ol> <li> <span class=\"code\">send()</span> is used to send funds to another user, and automatically handles the underlying cryptography required </li> <li> <span class=\"code\">generatePrivateKeys()</span> prompts the user for a signature and generates their spending and viewing keys. <span class=\"text-italic\"> Note: make sure the wallet being used supports deterministic ECDSA signatures with <a class=\"hyperlink\" href=\"https://tools.ietf.org/html/rfc6979\" target=\"_blank\">RFC 6979</a>. </span> </li> <li> <span class=\"code\">scan()</span> lets you find funds sent to the specified user, by providing just the user’s spending public key and viewing private key </li> <li> <span class=\"code\">withdraw()</span> lets a stealth address directly withdraw both tokens and ETH </li> <li> <span class=\"code\">withdrawOnBehalf()</span> uses meta-transactions to relay a withdraw transaction on behalf of another user, and the <span class=\"code\">signWithdraw()</span> method is used to get the required signature </li> <li> <span class=\"code\">relayWithdrawOnBehalf()</span> can be used to relay a meta-transaction using the default Umbra relayer </li> </ol> </li> <li> <span class=\"code\">src/classes/KeyPair.ts</span>: This class is where the core cryptography logic lives. A <span class=\"code\">KeyPair</span> class is instantiated with either a private or public key, and the class methods help you perform various operations with those keys, including encryption/decryption, multiplication, and compression/decompression of public keys </li> <li> <span class=\"code\">src/classes/RandomNumber.ts</span>: This simple class is used to generate our 32 byte random number. </li> <li> <span class=\"code\">src/utils/utils.ts</span> contains various helper methods for a range of tasks, primarily related to getting a recipient’s public keys </li> <li> <span class=\"code\">src/types.ts</span>: You’ll see a few custom types used throughout, which are all defined here </li> </ol> <p> After reading through the above, you should be well-equipped to understand the Umbra.sol contract, which you’ll notice is actually quite simple. The one new part in the contract which you won’t have seen anything about yet is the hooks. You can read more about this in the \"What are Hooks and how do I use them?\" section. </p>",
    "receive-vkey": "How can I receive a user’s viewing key, but not their spending key?",
    "receive-vkey-answer": "<p> Currently, the only way to do this is request a user’s signature using <span class=\"code\">Umbra.generatePrivateKeys()</span>, which will return both their spending key and their viewing key. It’s up to you to discard the spending key and not use it. A sample snippet to do this is below: </p> <div class=\"text-caption bg-muted q-pa-md\"> <div class=\"code code-grey\">// Import the Umbra class</div> <div class=\"code code\"> <span class=\"code-blue\">import </span> <span class=\"text-grey\">{</span> Umbra <span class=\"text-grey\">} </span> <span class=\"code-blue\">from</span> <span class=\"code-green\">'@umbra/umbra-js'</span>; </div> <br /> <div class=\"code code-grey\">// Let `signer` be an ethers JsonRpcSigner generated when the user</div> <div class=\"code code-grey\">// connected their wallet. The below line will request a signature</div> <div class=\"code code-grey\">// from the user, compute both their spending and viewing keys, but</div> <div class=\"code code-grey\">// only return the viewing KeyPair instance to the caller.</div> <div class=\"code code\"> <span class=\"code-blue\">const </span> <span class=\"text-grey\">{</span> viewingKeyPair <span class=\"text-grey\">}</span> = <span class=\"code-blue\">await</span> Umbra.<span class=\"code-pink\" >generatePrivateKeys</span >(signer); </div> </div>",
    "hooks": "What are Hooks and how do I use them?",
    "hooks-answer": "<p> If you’re familiar with <a class=\"hyperlink\" href=\"https://eips.ethereum.org/EIPS/eip-777\" target=\"_blank\">ERC-777</a> or other similar standards, you are already familiar with the concept of hooks. Hooks let the caller perform other actions in addition to the core logic of the method being called. In the case of ERC-777, a transfer hook can be used to call a method on a contract after transferring tokens to that contract. </p> <p> Umbra works similarly— when withdrawing funds from the contract— users might want to deposit them straight into Tornado, or swap their DAI for ETH. Hooks let you do this. </p> <p>You’ll notice the Umbra contract exposes multiple withdraw methods. First we have:</p> <ol> <li><span class=\"code\">withdrawToken()</span> for standard withdrawals, i.e. simple transfers</li> <li> <span class=\"code\">withdrawTokenOnBehalf()</span> has the same functionality as <span class=\"code\">withdrawToken()</span>, but lets a relayer submit the withdraw on your behalf to support meta-transactions. </li> </ol> <p>Then we have the two hook methods:</p> <ol> <li> <span class=\"code\">withdrawTokenAndCall()</span> is analogous to <span class=\"code\">withdrawToken()</span>, but lets you pass in the address of a contract and the data to call on that contract. </li> <li> <span class=\"code\">withdrawTokenAndCallOnBehalf()</span> is analogous to <span class=\"code\">withdrawTokenOnBehalf()</span>, but also lets you pass in the address of a contract and the data to call on that contract. </li> </ol> <p> To use hooks, first you need to write and deploy a hook contract conforming to the <span class=\"code\">IUmbraHookReceiver</span> interface. This requires the contract to implement a method calls <span class=\"code\">tokensWithdrawn()</span> that takes a handful of parameters. The address of this contract would be passed as the value for the <span class=\"code\">_hook</span> input in the above methods. </p> <p> Then you need to encode the calldata that the hook contract will receive and can operate on. See the <a class=\"hyperlink\" href=\"https://docs.ethers.io/v5/single-page/#/v5/api/utils/abi/interface/-%23-Interface--encoding\" target=\"_blank\" >Encoding Data</a > section of the ethers.js docs for info on how to encode function data. </p> <p> And that’s all there is to it. With the address of the hook contract and the encoded calldata, you are ready to call one of the two hook-based methods. </p>"
  }
}